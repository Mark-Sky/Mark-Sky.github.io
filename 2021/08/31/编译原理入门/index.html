<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>编译原理入门 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>




  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">Frame.</a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Complie/">
                            Complie
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                编译原理入门
            
            
        </div>
        <span class="post-date">
            Aug 31, 2021
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h1><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ul>
<li>效率高，一次编译，多次运行</li>
<li>通常目标程序是可执行的</li>
</ul>
<p>一个源代码文件，比如C文件，或者py文件，其内容并不能被机器识别运行，因此需要先编译为汇编语言，再转化为机器语言，在windows上的目标程序（可执行程序）就是exe文件，编译器只会编译一遍，生成一个可执行文件，以后用户只需要执行可执行文件，不需要再编译就可以运行，与源程序再也没有关系</p>
<p><img src="https://i.loli.net/2021/08/31/UQGviYcNXPy3Sel.png"></p>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><ul>
<li>直接利用用户提供的输入，执行源程序中指定的操作。</li>
<li>不生成目标程序，而是根据源程序的语义直接运行。</li>
<li>边解释，边执行，错误诊断效果好。</li>
</ul>
<p><img src="https://i.loli.net/2021/08/31/7n9x4MAhIXFGkaQ.png"></p>
<p>其实仍然需要生成可执行的代码才能运行，但是是逐条转换，而且不会保留可执行的代码，因此下一次再有程序输入时仍然需要解释器再重新编译源程序</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>如果举生活中的例子，编译器就相当于翻译一本英文书为中文书，只需要有一个人翻译出来，有了中文译本，用户就可以一直看中文译本而不需要再去看英文本了。解释器就相当于有一个人逐条翻译英文本给用户，用户可以一页页听着翻译来看完整本书，但是看完整本书后，不会留下译本，下次需要再看这本书的时候，还需要译者去逐条逐条地翻译才能看懂</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java的语言处理器结合了编译和解释的过程，一个Java源程序首先被编译成一个字节码(bytecode)的中间表示形式，然后由一个虚拟机对得到的字节码加以解释执行。这样会比每次都重新编译源程序要快，又能有解释的易进行错误诊断的效果</p>
<p>好处是再一台机器上编译得到的字节码可以再另一台机器上解释执行</p>
<p><img src="https://i.loli.net/2021/08/31/vQWGT6JYimoR4XA.png"></p>
<h1 id="从源程序到机器代码"><a href="#从源程序到机器代码" class="headerlink" title="从源程序到机器代码"></a>从源程序到机器代码</h1><p>这一部分是在计算机系统基础中的知识，在这里再复习下</p>
<ul>
<li>源程序$\to$ 预处理器$\to$​ 经过预处理的源程序（hello.c $\to$​ hello.i）</li>
</ul>
<p>预处理，比如宏定义的转换</p>
<ul>
<li>经过预处理的源程序$\to$ 编译器$\to$ 目标汇编程序 （helloc.i$\to$ hello.s）</li>
</ul>
<p>把高级语言的程序翻译为汇编语言程序</p>
<ul>
<li>目标汇编程序$\to$汇编器$\to$ 可重定位机器代码（hello.s $\to$ hello.o）</li>
</ul>
<p>生成可重定位的机器代码，也就是还没有经过链接的过程，变量的地址还不知道</p>
<ul>
<li>可重定位机器代码$\to$ 链接器/加载器$\to$ 目标机器代码（hello.o$\to$ hello.exe）</li>
</ul>
<p>链接库文件和可重定位对象文件，生成机器可以运行的机器代码，不同的操作系统的可执行文件不同</p>
<h1 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h1><h2 id="分析部分"><a href="#分析部分" class="headerlink" title="分析部分"></a>分析部分</h2><ul>
<li>把源程序分解为多个组成要素，并得到语法结构，用该语法结构创建源程序的一个中间表示</li>
<li>搜集源程序中的相关信息，放入符号表</li>
<li>分析，定位程序中可能存在的语法，语义错误</li>
<li>又称为编译器的前端，是与机器无关的部分</li>
</ul>
<h2 id="综合部分"><a href="#综合部分" class="headerlink" title="综合部分"></a>综合部分</h2><ul>
<li>根据符号表和中间表示构造目标程序</li>
<li>又称编译器的后端，是与机器相关的部分</li>
</ul>
<h1 id="编译器中的步骤"><a href="#编译器中的步骤" class="headerlink" title="编译器中的步骤"></a>编译器中的步骤</h1><p><img src="https://i.loli.net/2021/08/31/QbvJsqdoTrMU9uN.jpg"></p>
<p>除了上面标出来的，还有一个贯穿整个编译过程的东西，<strong>符号表</strong>，用于存放源程序的相关信息，可由各个步骤使用</p>
<p>下面的过程的例子将用一个简单的源程序语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position = initial + rate * <span class="number">60</span></span><br></pre></td></tr></table></figure>

<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>编译器的第一个步骤是词法分析(lexical analysis)，它读入组成源程序的字符流，并将他们组织成有意义的词素的序列（词素是语言学中能表达意思的最小单位，在英语中是单词，在汉语中则是汉字）</p>
<p>对于每个词素，词法分析器产生如下的<strong>词法单元</strong>作为输出:</p>
<p>$&lt;token-name,attribute-value&gt;$​</p>
<p>其中token-name是一个抽象符号，相同类型的词素会使用相同的抽象符号</p>
<p>而attribute-value指向符号表中关于这个词法单元的条目，也就是相当于一个指针</p>
<p>该词法单元会传递给下一个步骤，也就是语法分析</p>
<ul>
<li>position，initial，rate，=，+，*，60 都是词素</li>
</ul>
<table>
<thead>
<tr>
<th>词素</th>
<th>词法单元</th>
</tr>
</thead>
<tbody><tr>
<td>position</td>
<td>&lt;id, 1&gt;</td>
</tr>
<tr>
<td>initial</td>
<td>&lt;id, 2&gt;</td>
</tr>
<tr>
<td>rate</td>
<td>&lt;id, 3&gt;</td>
</tr>
<tr>
<td>=</td>
<td>&lt;=&gt;</td>
</tr>
<tr>
<td>+</td>
<td>&lt;+&gt;</td>
</tr>
<tr>
<td>*</td>
<td>&lt;*&gt;</td>
</tr>
<tr>
<td>60</td>
<td>&lt;60&gt;</td>
</tr>
</tbody></table>
<p>字符流变为符号流<br>$$<br>&lt;id, 1&gt;&lt;=&gt;&lt;id,2&gt;&lt;+&gt;&lt;id,3&gt;&lt;*&gt;&lt;60&gt;<br>$$</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p><img src="https://i.loli.net/2021/08/31/D3zLGAaEYq4XQFu.png"></p>
<ul>
<li>生成语法树</li>
<li>指出了词法单元流的语法结构</li>
</ul>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p><img src="https://i.loli.net/2021/08/31/oNkTWFrRZ8pgeJq.png"></p>
<ul>
<li>得到语义，对于编译器来说比较难</li>
<li>语义分析<ul>
<li>使用语法树和符号表中的信息，检查源程序是否满足语言定义的语义约束（比如，在C语言中，当&lt;id,3&gt;与60相乘，会检查&lt;id, 3&gt;是否为定义的数字类型，否则报错）</li>
<li>同时收集类型信息，用于代码生成</li>
<li>类型检查，类型转换（如果int类型与float类型相乘，就需要先把int扩展为float类型）</li>
</ul>
</li>
</ul>
<h3 id="语义分析的例子"><a href="#语义分析的例子" class="headerlink" title="语义分析的例子"></a>语义分析的例子</h3><p>自然语言中代词的分析</p>
<ul>
<li>Jack said Jerry left his assignment at home.</li>
<li>Jack said Jack left his assignment at home?</li>
</ul>
<p>第一句中的his指代的his是Jerry，人很容易看出来，但是怎么能让机器看出来</p>
<p>第二句中两个Jack是不是同一个人，his又是指代的哪一个Jack</p>
<p>而在程序设计中，也会出现类似的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> Jack = <span class="number">3</span>;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">int</span> Jack = <span class="number">4</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; Jack;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当中的Jack应该是哪一个值，机器需要怎么识别</p>
<h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><p><img src="https://i.loli.net/2021/08/31/Pnm3iFry4QZXJl5.png"></p>
<p>变成三地址代码：也就是每个指令最多包含3个运算分量</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><img src="https://i.loli.net/2021/08/31/38eCmqhBGOVQUYL.png"></p>
<p>改进中间代码，使用更少行代码，运行的更快，占用更少内存</p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p><img src="https://i.loli.net/2021/08/31/teQPw8fIJUOTNGd.png"></p>
<p>把中间表示形式映射到目标语言</p>
<ul>
<li>寄存器的分配</li>
<li>指令选择</li>
<li>内存分配</li>
</ul>
<h1 id="编译器的趟-Pass"><a href="#编译器的趟-Pass" class="headerlink" title="编译器的趟(Pass)"></a>编译器的趟(Pass)</h1><p>在一个特定的实现中，上面的多个步骤的活动可以被组合成一趟。每趟读入一个输入文件并产生一个输出文件</p>
<p>比如，前端步骤中的词法分析，语法分析，语义分析，以及中间代码生成可以被组合在一起成为一趟，然后可以有一个为特定目标机生成代码的后端趟</p>
<h1 id="人工智能编译器"><a href="#人工智能编译器" class="headerlink" title="人工智能编译器"></a>人工智能编译器</h1><p><img src="https://i.loli.net/2021/08/31/JZoOyiQK83mYatL.png"></p>
<p>现在有很多很火的人工智能深度学习框架，像是Pytorch和Keras，它们是不同的框架，但是最终都要运行在机器上，可以是CPU，也可以用GPU，TPU，如何让这些深度学习框架更快地运行在机器上面，有一部分就是编译器的工作</p>
<blockquote>
<p><strong>首先，由于前端接口和后端实现之间的差异，从一个人工智能框架切换到另一个AI框架是非常重要的</strong>。此外，算法开发人员可能会使用多个框架作为开发和交付流程的一部分。在AWS上，我们有客户希望在MXNet上部署他们的Caffe模型，以享受Amazon EC2上的高速性能。Joaquin Candela最近在博客中写道，用户可能会使用PyTorch进行快速开发，然后部署在Caffe2上。然而，在将模型从一个框架转换到另一个框架后，有人抱怨二者的调试结果存在差异。</p>
</blockquote>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2021/08/30/%E8%A1%A8%E4%B9%89%E6%96%87%E5%AD%97%E7%9A%84%E9%AD%85%E5%8A%9B/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://hexo.io/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

  </body>
</html>
