

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>傅里叶与机器学习 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>山里有座庙</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="傅里叶与机器学习">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-09 21:10" pubdate>
        2021年12月9日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      45
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">傅里叶与机器学习</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学院里面开设了数字信号处理这门课程，本来这个课是电子工程的必修课，然后我们也变成方向必修课了。一开始感觉很不理解，不知道这个东西有什么用，但是上完一学期的课，通过编程题作业，也逐渐感觉到这个课程的意义。于是现在想把这门课的核心-傅里叶变换与人工智能重合的部分整理总结一下。</p>
<p>所有的完整代码在github中<a target="_blank" rel="noopener" href="https://github.com/Mark-Sky/Fourier-and-AI">@Mark-Sky</a></p>
<h1 id="傅里叶变换与KSVM"><a href="#傅里叶变换与KSVM" class="headerlink" title="傅里叶变换与KSVM"></a>傅里叶变换与KSVM</h1><p>KSVM就是Kernel Support Vector Machine，核支持向量机</p>
<p>先说傅里叶变换对KSVM的作用：</p>
<div class="note note-success">
            <p><strong>通过傅里叶变换相关的知识，可以加速KSVM</strong></p>
          </div>

<h2 id="KSVM"><a href="#KSVM" class="headerlink" title="KSVM"></a>KSVM</h2><p>KSVM是对线性支持向量机的改进版，因为线性支持向量机仅能对线性可分的样本进行分类，而如异或问题就不是线性可分的。但是有下面的一个定理：</p>
<div class="note note-primary">
            <p>如果原始空间是有限维的，即属性数有限，那么一定存在一个高维特征空间使样本可分</p>
          </div>

<p>我们只需要把原始的样本投影到一个更高维的空间中就可以使得样本是线性可分的。因此原本的支持向量机的函数$f(x)=w^Tx+b$就变成了<br>$$<br>f(x)=w^T\phi(x)+b<br>$$<br>$\phi$就是一个一个$R^d\to R^D$的函数（$d&lt;D$）</p>
<p>而SVM的最优化问题<br>$$<br>\max\limits_{\alpha}\quad \sum\limits_{i=1}^m \alpha_i-\frac{1}{2}\sum\limits_{i=1}^n\sum\limits_{j=1}^m \alpha_i\alpha_jy_iy_jx_i^Tx_j<br>$$<br>变成了<br>$$<br>\max\limits_{\alpha}\quad \sum\limits_{i=1}^m \alpha_i-\frac{1}{2}\sum\limits_{i=1}^n\sum\limits_{j=1}^m \alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_j)<br>$$<br>在预测的时候，变成<br>$$<br>f(x)=\sum_{i=1}^m \alpha_i y_i\phi(x_i)^T\phi(x_j)+b<br>$$<br>看上面的$\phi(x_i)^T\phi(x_j)$，这有可能是两个很高维数的向量的内积，这样的内积是需要比较大的计算开销的，但是最后也仅仅是得到一个一维的数，因此我们会选择核函数来绕开这个内积，可以设想一个函数$k:R^d\times R^d\to R$<br>$$<br>k(x_i,x_j)=\phi(x_i)^T\phi(x_j)<br>$$<br>如果知道$\phi$的具体形式，那么核函数也可以很简单的写出来，但是一般来说，我们并不能知道把样本映射到什么高维空间里是合适的，所以就（乱搞一些核函数</p>
<p>反正就是有些核函数比较常用，而且能避免高维向量的内积导致的巨大计算开销</p>
<p>其中跟这篇博客相关的就是高斯核（RBF）<br>$$<br>k(x_i,x_j)=\exp(-\frac{||x_i-x_j||^2}{2\sigma^2})<br>$$<br>该高斯核的计算开销都是$O(d)$的，而不是$O(D)$，尽管如此，该方法还是很慢（我也没搞懂为什么hh，可能是线性SVM的一些加速操作无法对应到该方法上？）</p>
<div class="note note-success">
            <p>实际上对于时不变的核都可以用这个方法近似，只是$p(w)$需要做一些调整</p>
          </div>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>功利起见，先说怎么做，再回头看原理</p>
<p>假设一个线性不可分的数据集$(x_i,y_i)_{i=1}^n, x_i\in R^D$，对于每个$ x_i$，作如下变化</p>
<p>$$<br>z(x)=(\frac{1}{\sqrt R}z_{w1}(x),\frac{1}{\sqrt R}z_{w2}(x),…,\frac{1}{\sqrt R}z_{wR}(x))<br>$$</p>
<p>$$<br>z_{w}(x)=\sqrt 2 \cos (w^Tx+b)<br>$$</p>
<p>其中$R$是超参数，R越大，对核函数的近似度越高。</p>
<p>每个$w\in N_D(0,I)$，服从D维高斯分布</p>
<p>因此数据集变为$(z(x_i), y_i)_{i=1}^n$，$z(x_i)\in R^R$</p>
<p>然后就可以直接作为线性支持向量机的输入训练模型</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">RFF_approxiamte</span>(<span class="hljs-params">data_x, data_y</span>):</span><br>    n_dims = data_x.shape[<span class="hljs-number">1</span>]<br>    w = np.random.normal(size=(n_dims, r_features))<br>    b = np.random.uniform(low=<span class="hljs-number">0.0</span>, high=<span class="hljs-number">2</span> * np.pi, size=r_features)<br>    X = np.sqrt(<span class="hljs-number">2</span> / r_features) * np.cos(data_x @ w + b)<br>    clf = LinearSVC(random_state=<span class="hljs-number">0</span>, tol=<span class="hljs-number">1e-5</span>)<br>    clf.fit(X, data_y)<br> 	<span class="hljs-keyword">return</span> clf<br></code></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>下面尝试反着证明顺序来说明一下原理</p>
<p>对于两个样本$x,y$，转为$z(x),z(y)$，内积<br>$$<br>z(x)^Tz(y)=\frac{1}{R}\sum_{r=1}^R z_{wr}(x)z_{wr}(y)=\frac{1}{R} \sum_{r=1}^R 2\cos (w_r^Tx+b_r)\cos (w_r^Ty+b_r)<br>$$<br>用三角函数的和积化差公式，然后可以作为以w为自变量的期望值的近似<br>$$<br>E_w[\cos(w^T(x-y))]\approx\frac{1}{R}\sum_{r=1}^R \cos(w_r^T(x-y))<br>$$<br>由于我们要的核函数是在实数域上的，所以还可以用欧拉公式<br>$$<br>E_w[\exp(iw^T(x-y))]=E_w[\cos (w^T(x-y))]<br>$$<br>而上式左边可以展开<br>$$<br>E_w[\exp(iw^T(x-y))]=\int p(w)\exp(iw^T(x-y))dw<br>$$<br>通过一顿操作，可以得到<br>$$<br>E_w[\exp(iw^T(x-y))]=\exp(-\frac{1}{2}(x-y)^T(x-y))<br>$$<br>右边的可以看出就是高斯核的表达式。至此完成了用$z(x)$对高斯核的近似<br>$$<br>z(x)^Tz(y)\approx\exp(-\frac{1}{2}(x-y)^T(x-y))<br>$$<br>但是到底跟傅里叶有什么关系呢？实际上，上面的推导是根据一个大框架的原理得出的</p>
<div class="note note-success">
            <p>一个连续核函数$k(x,y)=k(x-y):R^D\times R^D\to R$是正定的当且仅当$k(\Delta)$是一个非负的度量的<strong>傅里叶变换</strong></p>
          </div>

<p>非负的度量，也就是$p(w)$，$w$服从的分布的概率密度函数，作傅里叶变换<br>$$<br>k(\Delta)=\int p(w)\exp(iw\Delta)dw<br>$$<br>在上面的实现中，用的概率密度函数是高斯分布的概率密度函数，而实际上任意取一种分布，对其作傅里叶变换，都可以得到一种时不变核函数</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>用Moon数据集，对线性SVM，高斯核SVM，RFF-SVM三种方法进行评估</p>
<p>首先是准确率，很直观看到，线性的只能划分一条横线，但是高斯核和RFF-SVM均可以对数据集做一个比较漂亮的划分（RFF-SVM的R设置为10000）</p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Pictureslinear_moon_data-1639234181289.jpg" srcset="/img/loading.gif" lazyload alt="linear_moon_data"></p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Picturesrbf_moon_data.jpg" srcset="/img/loading.gif" lazyload alt="rbf_moon_data"></p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20PicturesFastRFFmoon_data.jpg" srcset="/img/loading.gif" lazyload alt="FastRFFmoon_data"></p>
<p>然后是训练模型运行时间的对比（样本数为10000）</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>线性SVM</td>
<td>0.19608</td>
</tr>
<tr>
<td>RBF-SVM</td>
<td>2.979154</td>
</tr>
<tr>
<td>RFF-SVM（D=10000）</td>
<td>0.225546</td>
</tr>
</tbody></table>
<h1 id="傅里叶变换与DNN"><a href="#傅里叶变换与DNN" class="headerlink" title="傅里叶变换与DNN"></a>傅里叶变换与DNN</h1><p>一般来说，傅里叶变换是用于把时域的函数转化为频域上的函数，<strong>通过分析频域的函数，可以得到一些时域上看不出来的东西</strong>。</p>
<p>对于一个数据集$(x_i,y_i)_{i=1}^n$，可以把$x_i$看作时域上的自变量，也就是$t$，$y_i$则为时域上的函数值$x(t)$。机器学习需要学习的时域上的函数就是机器学习理论中的目标概念$c$，其中<br>$$<br>c(x_i)=y_i\quad i=1,2,…n<br>$$<br>在时域上我们希望通过学习得到一个尽量接近c的函数$f$，也就是<br>$$<br>P(E[P(f(x_i)\neq y_i)]\leq \epsilon)\geq 1-\delta<br>$$<br>简单来说，就是<br>$$<br>f(x_i)\approx y_i\quad i=1,2,…, n<br>$$<br>一个简单的例子：需要的目标概念为$c$(绿线)，而学习得到的函数为$f$(红线)</p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Pictures0-1639130931014.png" srcset="/img/loading.gif" lazyload alt="训练第0轮"></p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Pictures1000-1639131007447.png" srcset="/img/loading.gif" lazyload alt="训练第1000轮"></p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Pictures2000-1639131026535.png" srcset="/img/loading.gif" lazyload alt="训练第3000轮"></p>
<p>上面的函数拟合过程是在频域上的拟合过程</p>
<p>那么<strong>如何把$f$函数的拟合过程转到频域上分析</strong>呢？在<strong>频域上分析又能得到什么结论</strong>呢？</p>
<p>下面均以手写数字图像识别数据集MNIST作为例子</p>
<h2 id="F-Principle"><a href="#F-Principle" class="headerlink" title="F-Principle"></a>F-Principle</h2><p>首先说结论，在频域上分析，可以得到下面的频率原理</p>
<div class="note note-success">
            <p><strong>深度神经网络DNN总是先拟合低频的部分，然后再拟合高频的部分</strong></p>
          </div>

<p>关于这一点，比较直观的例子就是之前的博客中的RNN的字符级模型，它会在一开始先拟合一些如句子中的空格和标点符号，然后慢慢开始拟合单词，最后会拟合句子的语法。简单的部分也就是低频的部分，很快就会拟合完成，比较难的部分就是高频的部分，需要较多的训练回数才会拟合。</p>
<h2 id="高频与低频"><a href="#高频与低频" class="headerlink" title="高频与低频"></a>高频与低频</h2><p>为了更好的理解F-Principle，即频率原理，需要对数据的高频与低频有一个更好的理解</p>
<p>在频率原理中，研究的频率是指<strong>反应频率</strong>，而另一个容易与之混淆的概念是 <strong>输入频率</strong></p>
<ul>
<li>反应频率：描述的是不同的输入导致的输出的变化的幅度，对象是函数</li>
<li>输入频率：描述的是一个输入的不同维度上面的取值的变化的幅度，对象只是输入</li>
</ul>
<p>举个例子：</p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Picturesimage-20211210193438229.png" srcset="/img/loading.gif" lazyload alt="低输入频率与高输入频率"></p>
<p>上图的左图的输入频率为0，输入为图像的所有的像素点构成的向量，该向量的不同维度的变化基本为零，如第1个像素点到第2个像素点，其颜色没有变化，所以该图像的输入频率为0。而右图的像素点的颜色变化很大，向量的不同维度的变化幅度较大，因此是高输入频率的</p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Picturesimage-20211210194009700.png" srcset="/img/loading.gif" lazyload alt="反应频率"></p>
<p>反应频率描述的对象是机器学习得到的函数，如函数的期望值和方差就是函数的低频部分，函数的高阶矩就是高频部分，可以对比期望值和方差与傅里叶变换的计算，可以理解期望值就是$w=1$的情况，而方差就是$w=2$的情况<br>$$<br>E[f]=\int xf(x)dx<br>$$</p>
<p>$$<br>Var=\int x^2f(x)dx<br>$$</p>
<p>$$<br>X(jw)=F[x(t)]=\int f(t)\cdot e^{-jwt}dt=\int f(t)\cdot (e^{-jt})^{w}dt<br>$$</p>
<p>若函数的反应频率高频部分的振幅较大的话，则说明该学习到的函数容易收到噪音的干扰，如上图识别熊猫，若加上一个噪音的话，实际上图像中我们并没有看出来有多大的区别，但是由于机器学习得到的函数的高频部分较大，导致较小的输入变化会使得输出会有较大的变化，最终得到的预测结果也从”熊猫”变成了”长臂猿”</p>
<div class="note note-success">
            <p>个人的思考</p><p>通过频域的分析，可以对一个<strong>机器学习任务的难度</strong>作一个有数学定义的具体的判断，若该任务的高频部分的振幅较大，则说明较小的输入变化会导致较大的输出变化，那么就要求模型去抓取这个较小的变化，然后对应到输出，需要的观测精度较高，就说明该任务的学习难度是比较大的</p><p>对于算法学习得到的模型函数，通过傅里叶变换，还可以对学习得到的函数的<strong>稳定性</strong>做一个有数学定义的具体的判断。若该函数的高频部分的振幅较大，则说明该函数会很容易捕捉到很微小的输入变化，但与此同时，该函数也会很容易被噪音影响，对数据集做一些微小的扰动可能就会使得输出有较大的变化，这就说明该函数的稳定性较差，这是我们在大多数的学习任务里面都不希望看到的</p>
          </div>

<h2 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h2><p>对于输入为单维度的函数$f$，只需要分析单维度的频域<br>$$<br>F(k)=F[f]=\frac{1}{n}\sum_{i=0}^{n-1}f(x_i)\exp(-i2\pi kx_i)<br>$$<br>上式的k表示频率（频域的自变量），数据集的大小为n，该式叫非均匀离散傅里叶变换</p>
<p>可以对比离散傅里叶变化（DFT）<br>$$<br>X[k]=\sum_{n=0}^{N-1}x[n]\cdot e^{-i2\pi nk/N}<br>$$<br>可以发现，非均匀的意思应该就是在指数的幂次那里添加了$x_i$一项，而不是均匀的$\frac{1}{N}$</p>
<p>言归正传，单维度的输入做傅里叶变换的开销是比较小的，因为只需要看但单个维度的频域，想要计算不同频率下的振幅，只需要改变单个k值，然后用上述公式计算</p>
<p>然而在函数的输入为向量的时候，傅里叶变换的定义公式变为<br>$$<br>F(\vec{k})=F[f]=\frac{1}{n}\sum_{i=0}^{n-1}f(x_i)\exp(-i2\pi \vec{k}\cdot\vec{x_i})<br>$$<br>当输入的维度大小为10维，则$\vec{k}$的维度也变为10维，即使是每个维度上k的取值都是二值，也会有$2^{10}$种$\vec{k}$，因此高维的傅里叶变换的分析会出现维数灾难的问题。为了解决该问题，F-Principle的原论文作者提出了两种解决方案，因为笔者只实现了第一种方案，所以在这里仅仅介绍第一种方案。</p>
<h2 id="投影方法"><a href="#投影方法" class="headerlink" title="投影方法"></a>投影方法</h2><p>通过把$\vec{k}$投影到一个固定的方向$\vec p_1$，实现降维，以此来避免维数灾难<br>$$<br>\vec k=k\vec p_1<br>$$<br>原本n维的$\vec{k}$变成了一维的$k$，只需要跟上面的单输入的低维度傅里叶变换一样了<br>$$<br>F(k)=F[f]=\frac{1}{n}\sum_{i=0}^{n-1}f(x_i)\exp(-i2\pi k\vec{p}_i\vec{x}_i)<br>$$<br>而怎么选择这个固定的方向$\vec{p}_1$来降维呢？论文的作者用的是数据集的主成分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pca = PCA(n_components=<span class="hljs-number">1</span>)<br>pca.fit(train_x)<br>projection_k = torch.tensor(pca.components_, dtype=torch.float32, device=device)<br></code></pre></td></tr></table></figure>

<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">highD_NUDFT</span>(<span class="hljs-params">x_input, y_input, p1, freq_len=<span class="hljs-number">100</span>, min_f=<span class="hljs-number">0</span>,max_f=<span class="hljs-number">0.5</span>, isnorm=<span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-comment"># x_input: n x dim, p1: 1 x dim, k: freq_len x 1, y_input: n x y_dim</span><br>    n = x_input.shape[<span class="hljs-number">0</span>]<br>    dim = x_input.shape[<span class="hljs-number">1</span>]<br>    k = np.linspace(<span class="hljs-number">1</span>/np.pi, max_f, num=freq_len, endpoint=<span class="hljs-literal">True</span>)<br>    xp1 = np.matmul(x_input, p1.reshape([dim, <span class="hljs-number">1</span>])) <span class="hljs-comment"># n x 1</span><br>    kxp1 = xp1.repeat(freq_len, axis=<span class="hljs-number">1</span>) * k <span class="hljs-comment"># (n x freq_len)</span><br>    return_fft = np.matmul(np.transpose(y_input), np.exp(-<span class="hljs-number">1J</span> * <span class="hljs-number">2</span> * np.pi * kxp1)) <span class="hljs-comment"># (y_dim x freq_len)</span><br><br>    <span class="hljs-keyword">if</span> isnorm==<span class="hljs-number">1</span>:<br>        return_fft=np.absolute(return_fft)<br><br>    <span class="hljs-keyword">return</span> k, np.transpose(np.squeeze(return_fft))<br></code></pre></td></tr></table></figure>

<h2 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h2><p>最后还需要对函数的频域上的拟合过程用数学公式来直观具体地表示<br>$$<br>\Delta_F(k)=||h_k-y_k||/||y_k||<br>$$<br>其中$h_k$表示机器学习的函数的傅里叶变换，而$y_k$表示数据集的目标函数的傅里叶变换</p>
<p>$h_k,y_k$都是复数，因此为了使得分析的对象具有实际的物理意义，使用复数的范数</p>
<p>取几个不同的k，观察在不同的训练轮数的上述的$\Delta_F(k)$的取值</p>
<p><img src="https://raw.githubusercontent.com/Mark-Sky/picGo/main/C%3A%5CUsers%5Czqf%5COneDrive%5C%E5%9B%BE%E7%89%87%5CSaved%20Pictures%E9%AB%98%E9%A2%91%E4%B8%8E%E4%BD%8E%E9%A2%91%E6%8B%9F%E5%90%88%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83-1639147864156.png" srcset="/img/loading.gif" lazyload alt="高频与低频拟合速度比较"></p>
<p>上图中，横坐标表示训练的轮数，纵坐标从0到4，代表采样的频率点从低频到高频，0为5个采样点中最低频的点，而4则为最高频的点。可以看到，低频的点（0，1，2）很快就收敛了，拟合误差在很早的训练回数中就变成深蓝色，而高频的点（3，4）要到训练回数较高时才会收敛到浅蓝色。</p>
<p>该实验结果与频率原理是一致的：</p>
<p><strong>深度神经网络总是先拟合目标函数的低频部分，然后再拟合函数的高频部分</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Technology/">Technology</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/ML/">ML</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/14/Python%E5%BF%85%E8%A3%85/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/03/%E5%8A%A8%E6%BC%AB%E5%8F%B0%E8%AF%8D%E6%8A%84%E5%BD%95/">
                        <span class="hidden-mobile">动漫台词抄录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
